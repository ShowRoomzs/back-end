name: Deploy Spring Boot to EC2 with Docker

on:
  push:
    branches:
      - main 
  workflow_dispatch:  

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: showroomz-backend
  S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET }}
  CODEDEPLOY_APP_NAME: spring-boot-app
  CODEDEPLOY_GROUP_NAME: spring-boot-deploy-group
  CONTAINER_IMAGE_TAG: ${{ github.sha }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    # [변경됨] OIDC 인증을 위한 권한 설정 추가
    permissions:
      id-token: write
      contents: read

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: showroomz
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
    - name: 소스 코드 체크아웃
      uses: actions/checkout@v3

    - name: Java 21 설정
      uses: actions/setup-java@v3
      with:
        distribution: 'corretto'
        java-version: '21'
        cache: 'gradle'

    # 2. GitHub Secret을 이용해 .env 파일 생성 (기존 유지)
    - name: Make .env file
      run: |
        echo "${{ secrets.APPLICATION_ENV }}" > .env
      shell: bash

    # 3. 통합 테스트 실행 (기존 유지, 경로만 back-end 반영)
    - name: Run Integration Tests (DB Schema Validation)
      run: |
        cd back-end
        chmod +x gradlew
        ./gradlew integrationTest
      env:
        SPRING_DATASOURCE_URL: jdbc:mysql://127.0.0.1:3306/showroomz?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8
        SPRING_DATASOURCE_USERNAME: root
        SPRING_DATASOURCE_PASSWORD: root

    # 4. Gradle 빌드 (JAR 생성)
    - name: Gradle 빌드
      run: |
        cd back-end
        chmod +x gradlew
        ./gradlew clean build -x test

    # [변경됨] AWS 로그인 (OIDC 방식 사용)
    # 기존 Access Key 방식 대신 IAM Role을 Assume 하는 방식으로 변경
    # GitHub Secrets에 'AWS_ROLE_ARN'을 추가해야 합니다.
    - name: AWS 로그인 (OIDC 사용)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    # [추가됨] 5. ECR 로그인
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    # [추가됨] 6. Docker 이미지 빌드 및 ECR 푸시
    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # back-end 폴더를 컨텍스트로 사용하여 Docker 빌드
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY:$CONTAINER_IMAGE_TAG \
                     back-end
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$CONTAINER_IMAGE_TAG

    # 7. 배포 파일 준비 및 S3 업로드 (JAR 제외, 스크립트 및 설정만 포함)
    - name: Zip deployment files and Upload to S3
      run: |
        mkdir deploy_artifact
        
        # appspec.yml과 scripts 폴더 복사 (back-end 폴더 기준)
        cp back-end/appspec.yml deploy_artifact/
        cp -r back-end/scripts deploy_artifact/
        
        # [중요] .env 파일도 배포 아티팩트에 포함 (컨테이너 실행 시 사용)
        cp .env deploy_artifact/
        
        # 압축 (CodeDeploy용)
        cd deploy_artifact
        zip -r ../deploy.zip .
        cd ..
        
        # S3 업로드
        aws s3 cp deploy.zip s3://$S3_BUCKET_NAME/deploy.zip

    # 8. CodeDeploy 실행 (기존 유지)
    - name: AWS CodeDeploy 실행
      run: |
        aws deploy create-deployment \
          --application-name $CODEDEPLOY_APP_NAME \
          --deployment-config-name CodeDeployDefault.OneAtATime \
          --deployment-group-name $CODEDEPLOY_GROUP_NAME \
          --s3-location bucket=$S3_BUCKET_NAME,bundleType=zip,key=deploy.zip

    # 9. Discord 알림 (성공 시) - 기존 유지
    - name: Discord 알림 (성공 시)
      if: ${{ success() }}
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # 1. 커밋 메시지 가져오기
        COMMIT_MSG=$(git log -1 --pretty=%B | head -1)

        # 2. PR 정보 가져오기
        PR_DATA=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
          "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}/pulls" | jq -r '.[0]' 2>/dev/null)

        # 3. 데이터 추출 (특수문자 처리를 jq에게 맡기기 위해 원본 그대로 변수에 저장)
        PR_TITLE=$(echo "$PR_DATA" | jq -r '.title // empty')
        PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number // empty')
        # 본문은 최대 1000자까지만 가져오기 (Discord 길이 제한 고려)
        PR_BODY=$(echo "$PR_DATA" | jq -r '.body // empty' | head -c 1000)

        # 4. PR 정보 유무에 따라 메시지 내용 구성
        if [ -z "$PR_TITLE" ]; then
          # PR이 없는 경우 커밋 메시지 사용
          MESSAGE_CONTENT="✅ **배포 성공**

          Repo: ${GITHUB_REPOSITORY}
          Branch: ${GITHUB_REF_NAME}
          Commit: ${GITHUB_SHA:0:7}
          Message: ${COMMIT_MSG}
          Triggered by: ${GITHUB_ACTOR}"
        else
          # PR이 있는 경우 (본문 포함)
          MESSAGE_CONTENT="✅ **배포 성공**

          📦 **PR 정보**
          제목: ${PR_TITLE}
          번호: #${PR_NUMBER}

          ${PR_BODY}

          🔗 **기타 정보**
          Repo: ${GITHUB_REPOSITORY}
          Branch: ${GITHUB_REF_NAME}
          Commit: ${GITHUB_SHA:0:7}
          Triggered by: ${GITHUB_ACTOR}"
        fi

        # 5. jq를 사용하여 안전하게 JSON Payload 생성 (--arg 사용)
        PAYLOAD=$(jq -n \
                  --arg username "GitHub Actions" \
                  --arg content "$MESSAGE_CONTENT" \
                  '{username: $username, content: $content}')

        # 6. Discord 전송
        curl -H "Content-Type: application/json" \
          -d "$PAYLOAD" \
          $DISCORD_WEBHOOK

name: Deploy Spring Boot to EC2 with Docker

on:
  push:
    branches:
      - main 
  workflow_dispatch:  

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: showroomz-backend
  S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET }}
  CODEDEPLOY_APP_NAME: showroomz-backend
  CODEDEPLOY_GROUP_NAME: showroomz-backend-prod
  CONTAINER_IMAGE_TAG: ${{ github.sha }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    # [변경됨] OIDC 인증을 위한 권한 설정 추가
    permissions:
      id-token: write
      contents: read

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: showroomz
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
    - name: 소스 코드 체크아웃
      uses: actions/checkout@v3

    - name: Java 21 설정
      uses: actions/setup-java@v3
      with:
        distribution: 'corretto'
        java-version: '21'
        cache: 'gradle'

    # 2. GitHub Secret을 이용해 .env 파일 생성 (기존 유지)
    - name: Make .env file
      run: |
        echo "${{ secrets.APPLICATION_ENV }}" > .env
      shell: bash

    # 3. 통합 테스트 실행
    - name: Run Integration Tests (DB Schema Validation)
      run: |
        chmod +x gradlew
        ./gradlew integrationTest
      env:
        SPRING_DATASOURCE_URL: jdbc:mysql://127.0.0.1:3306/showroomz?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8
        SPRING_DATASOURCE_USERNAME: root
        SPRING_DATASOURCE_PASSWORD: root

    # 4. Gradle 빌드 (JAR 생성)
    - name: Gradle 빌드
      run: |
        chmod +x gradlew
        ./gradlew clean build -x test

    # AWS 로그인 (OIDC 사용)
    - name: AWS 로그인 (OIDC 사용)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    # 5. ECR 로그인
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    # [추가됨] 멀티 아키텍처 빌드를 위한 QEMU 설정
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    # [추가됨] Docker Buildx 설정 (ARM 빌드 지원용)
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # [변경됨] 6. Docker 이미지 빌드 및 ECR 푸시 (ARM64 아키텍처 지정)
    - name: Build and push
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        # 태그 설정 (latest와 커밋 해시 태그 두 개 생성)
        tags: |
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.CONTAINER_IMAGE_TAG }}
        # [핵심] EC2(t4g) 아키텍처에 맞춰 linux/arm64로 빌드
        platforms: linux/arm64
        provenance: false

    # 7. 배포 파일 준비 및 S3 업로드
    - name: Zip deployment files and Upload to S3
      run: |
        mkdir deploy_artifact
        
        # appspec.yml, scripts 복사
        cp appspec.yml deploy_artifact/
        cp -r scripts deploy_artifact/
        
        # .env 파일 복사
        cp .env deploy_artifact/

        # docker-compose.yml 파일 복사
        cp docker-compose.yml deploy_artifact/
        
        # 압축 및 업로드
        cd deploy_artifact
        zip -r ../deploy.zip .
        cd ..
        
        # S3 업로드
        aws s3 cp deploy.zip s3://$S3_BUCKET_NAME/deploy.zip

    # 8. CodeDeploy 실행
    - name: AWS CodeDeploy 실행
      run: |
        aws deploy create-deployment \
          --application-name $CODEDEPLOY_APP_NAME \
          --deployment-config-name CodeDeployDefault.OneAtATime \
          --deployment-group-name $CODEDEPLOY_GROUP_NAME \
          --s3-location bucket=$S3_BUCKET_NAME,bundleType=zip,key=deploy.zip

    # 9. Discord 알림 (성공 시)
    - name: Discord 알림 (성공 시)
      if: ${{ success() }}
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # 1. 커밋 메시지 가져오기
        COMMIT_MSG=$(git log -1 --pretty=%B | head -1)

        # 2. PR 정보 가져오기
        PR_DATA=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
          "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}/pulls" | jq -r '.[0]' 2>/dev/null)

        # 3. 데이터 추출 (특수문자 처리를 jq에게 맡기기 위해 원본 그대로 변수에 저장)
        PR_TITLE=$(echo "$PR_DATA" | jq -r '.title // empty')
        PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number // empty')
        # 본문은 최대 1000자까지만 가져오기 (Discord 길이 제한 고려)
        PR_BODY=$(echo "$PR_DATA" | jq -r '.body // empty' | head -c 1000)

        # 4. PR 정보 유무에 따라 메시지 내용 구성
        if [ -z "$PR_TITLE" ]; then
          # PR이 없는 경우 커밋 메시지 사용
          MESSAGE_CONTENT="✅ **배포 성공**

          Repo: ${GITHUB_REPOSITORY}
          Branch: ${GITHUB_REF_NAME}
          Commit: ${GITHUB_SHA:0:7}
          Message: ${COMMIT_MSG}
          Triggered by: ${GITHUB_ACTOR}"
        else
          # PR이 있는 경우 (본문 포함)
          MESSAGE_CONTENT="✅ **배포 성공**

          📦 **PR 정보**
          제목: ${PR_TITLE}
          번호: #${PR_NUMBER}

          ${PR_BODY}


          🔗 **기타 정보**
          Repo: ${GITHUB_REPOSITORY}
          Branch: ${GITHUB_REF_NAME}
          Commit: ${GITHUB_SHA:0:7}
          Triggered by: ${GITHUB_ACTOR}"
        fi

        # 5. jq를 사용하여 안전하게 JSON Payload 생성 (--arg 사용)
        PAYLOAD=$(jq -n \
                  --arg username "GitHub Actions" \
                  --arg content "$MESSAGE_CONTENT" \
                  '{username: $username, content: $content}')

        # 6. Discord 전송
        curl -H "Content-Type: application/json" \
          -d "$PAYLOAD" \
          $DISCORD_WEBHOOK
